"""
Decision policy for NPC action selection.

Defines a finite set of actions an NPC can take and provides
deterministic selection based on context and learned weights.
"""
from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Tuple
import logging

logger = logging.getLogger(__name__)


class NPCAction(str, Enum):
    """
    Finite set of NPC actions.
    
    These are high-level intentions, not implementations.
    The actual dialogue/behavior is still generated by the LLM,
    but constrained by the chosen action.
    """
    # Conversation actions
    ACT_GREET = "greet"
    ACT_SMALLTALK = "smalltalk"
    ACT_ASK_QUESTION = "ask_question"
    ACT_GIVE_INFO = "give_info"
    ACT_DEFLECT = "deflect"
    ACT_END_CONVERSATION = "end_conversation"
    
    # Quest actions
    ACT_OFFER_QUEST = "offer_quest"
    ACT_ACCEPT_QUEST = "accept_quest"
    ACT_DECLINE = "decline"
    ACT_REQUEST_HELP = "request_help"
    
    # Economic actions
    ACT_BARTER = "barter"
    ACT_OFFER_GIFT = "offer_gift"
    ACT_REQUEST_ITEM = "request_item"
    
    # Movement/following actions
    ACT_FOLLOW = "follow"
    ACT_WAIT = "wait"
    ACT_DISENGAGE = "disengage"
    ACT_APPROACH = "approach"
    
    # Defensive/hostile actions
    ACT_WARN = "warn"
    ACT_THREATEN = "threaten"
    ACT_CALL_GUARD = "call_guard"
    ACT_FLEE = "flee"
    
    # Emotional actions
    ACT_EXPRESS_GRATITUDE = "express_gratitude"
    ACT_EXPRESS_CONCERN = "express_concern"
    ACT_APOLOGIZE = "apologize"
    ACT_COMPLAIN = "complain"


@dataclass
class ActionConstraints:
    """Constraints for when an action is allowed."""
    min_affinity: float = -1.0  # Minimum affinity required
    max_affinity: float = 1.0   # Maximum affinity allowed
    forbidden_moods: List[str] = None  # Moods that prevent this action
    
    def __post_init__(self):
        if self.forbidden_moods is None:
            self.forbidden_moods = []
    
    def is_allowed(self, affinity: float, mood: str) -> bool:
        """Check if action is allowed given current state."""
        if affinity < self.min_affinity or affinity > self.max_affinity:
            return False
        if mood in self.forbidden_moods:
            return False
        return True


# Define constraints for each action
ACTION_CONSTRAINTS: Dict[NPCAction, ActionConstraints] = {
    # Hostile actions require low affinity
    NPCAction.ACT_THREATEN: ActionConstraints(
        max_affinity=-0.3,
        forbidden_moods=["Pleased", "Warm", "Grateful"]
    ),
    NPCAction.ACT_CALL_GUARD: ActionConstraints(
        max_affinity=-0.5,
        forbidden_moods=["Pleased", "Warm", "Grateful", "Neutral"]
    ),
    NPCAction.ACT_FLEE: ActionConstraints(
        max_affinity=-0.4,
        forbidden_moods=["Pleased", "Warm"]
    ),
    
    # Friendly actions require moderate to high affinity
    NPCAction.ACT_OFFER_QUEST: ActionConstraints(min_affinity=0.2),
    NPCAction.ACT_OFFER_GIFT: ActionConstraints(min_affinity=0.4),
    NPCAction.ACT_FOLLOW: ActionConstraints(min_affinity=0.3),
    
    # Gratitude requires positive affinity
    NPCAction.ACT_EXPRESS_GRATITUDE: ActionConstraints(min_affinity=0.1),
    
    # Warning is for neutral to slightly negative
    NPCAction.ACT_WARN: ActionConstraints(
        min_affinity=-0.5,
        max_affinity=0.3
    ),
}


class DecisionPolicy:
    """
    Selects NPC actions based on context and learned weights.
    
    Key principles:
    - Deterministic: same context + weights -> same action
    - Bounded: only selects from pre-defined action set
    - Safe: respects affinity/mood constraints
    """
    
    def __init__(self, enabled: bool = False):
        """
        Initialize decision policy.
        
        Args:
            enabled: Whether decision layer is active (default: False)
        """
        self.enabled = enabled
    
    def get_allowed_actions(
        self,
        affinity: float,
        mood: str,
    ) -> List[NPCAction]:
        """
        Get list of actions allowed in current state.
        
        Args:
            affinity: Current affinity level (-1.0 to 1.0)
            mood: Current mood string
            
        Returns:
            List of allowed NPCAction values
        """
        allowed = []
        
        for action in NPCAction:
            constraints = ACTION_CONSTRAINTS.get(action)
            if constraints is None:
                # No constraints = always allowed
                allowed.append(action)
            elif constraints.is_allowed(affinity, mood):
                allowed.append(action)
        
        return allowed
    
    def choose_action(
        self,
        context_key: str,
        affinity: float,
        mood: str,
        action_weights: Optional[Dict[str, float]] = None,
    ) -> Tuple[NPCAction, str]:
        """
        Choose an action deterministically.
        
        Args:
            context_key: Context identifier (from build_context_key)
            affinity: Current affinity level
            mood: Current mood
            action_weights: Optional learned weights for actions
            
        Returns:
            Tuple of (chosen_action, speech_style_hint)
        """
        if not self.enabled:
            # Default to smalltalk when disabled
            return NPCAction.ACT_SMALLTALK, "neutral"
        
        # Get allowed actions
        allowed = self.get_allowed_actions(affinity, mood)
        
        if not allowed:
            # Fallback if no actions allowed (shouldn't happen)
            logger.warning(
                f"No actions allowed for affinity={affinity}, mood={mood}"
            )
            return NPCAction.ACT_DEFLECT, "neutral"
        
        # If no weights provided, choose first allowed action deterministically
        if action_weights is None or len(action_weights) == 0:
            return allowed[0], self._get_style_for_action(allowed[0], affinity)
        
        # Score allowed actions by weight
        scored = []
        for action in allowed:
            weight = action_weights.get(action.value, 1.0)
            scored.append((weight, action))
        
        # Deterministic argmax (stable sort by action name for ties)
        scored.sort(key=lambda x: (x[0], x[1].value), reverse=True)
        chosen = scored[0][1]
        
        return chosen, self._get_style_for_action(chosen, affinity)
    
    def _get_style_for_action(
        self,
        action: NPCAction,
        affinity: float,
    ) -> str:
        """
        Map action to a speech style hint.
        
        Args:
            action: The chosen action
            affinity: Current affinity level
            
        Returns:
            Style hint string (neutral, warm, firm, etc.)
        """
        # Map actions to styles
        if action in [NPCAction.ACT_THREATEN, NPCAction.ACT_CALL_GUARD]:
            return "hostile"
        elif action in [NPCAction.ACT_WARN, NPCAction.ACT_DECLINE]:
            return "firm"
        elif action in [NPCAction.ACT_OFFER_GIFT, NPCAction.ACT_EXPRESS_GRATITUDE]:
            return "warm"
        elif action == NPCAction.ACT_APOLOGIZE:
            return "apologetic"
        elif action in [NPCAction.ACT_DEFLECT, NPCAction.ACT_END_CONVERSATION]:
            return "concise"
        
        # Default based on affinity
        if affinity >= 0.5:
            return "warm"
        elif affinity >= 0.0:
            return "neutral"
        elif affinity >= -0.5:
            return "firm"
        else:
            return "hostile"
    
    def get_llm_directive(self, action: NPCAction) -> str:
        """
        Convert action to LLM directive.
        
        Args:
            action: The chosen action
            
        Returns:
            Directive string to include in LLM prompt
        """
        directives = {
            NPCAction.ACT_GREET: "Greet the player warmly or appropriately for your mood.",
            NPCAction.ACT_SMALLTALK: "Make casual conversation.",
            NPCAction.ACT_ASK_QUESTION: "Ask the player a question to learn more.",
            NPCAction.ACT_GIVE_INFO: "Provide helpful information.",
            NPCAction.ACT_DEFLECT: "Deflect or avoid the topic politely.",
            NPCAction.ACT_END_CONVERSATION: "Politely end the conversation.",
            
            NPCAction.ACT_OFFER_QUEST: "Mention a task or quest the player could help with.",
            NPCAction.ACT_ACCEPT_QUEST: "Accept the player's offer to help.",
            NPCAction.ACT_DECLINE: "Decline the request politely but firmly.",
            NPCAction.ACT_REQUEST_HELP: "Ask the player for assistance.",
            
            NPCAction.ACT_BARTER: "Express interest in trading or commerce.",
            NPCAction.ACT_OFFER_GIFT: "Offer the player something as a token of appreciation.",
            NPCAction.ACT_REQUEST_ITEM: "Ask the player for an item you need.",
            
            NPCAction.ACT_FOLLOW: "Express willingness to accompany the player.",
            NPCAction.ACT_WAIT: "Indicate you'll wait here for the player.",
            NPCAction.ACT_DISENGAGE: "Excuse yourself from the interaction.",
            NPCAction.ACT_APPROACH: "Move toward or show interest in the player.",
            
            NPCAction.ACT_WARN: "Issue a warning about consequences.",
            NPCAction.ACT_THREATEN: "Make a direct threat.",
            NPCAction.ACT_CALL_GUARD: "Call for the guards or express intent to report.",
            NPCAction.ACT_FLEE: "Express fear and desire to leave immediately.",
            
            NPCAction.ACT_EXPRESS_GRATITUDE: "Thank the player sincerely.",
            NPCAction.ACT_EXPRESS_CONCERN: "Voice worry or concern.",
            NPCAction.ACT_APOLOGIZE: "Offer an apology.",
            NPCAction.ACT_COMPLAIN: "Express frustration or complaint.",
        }
        
        return directives.get(
            action,
            "Respond naturally to the player."
        )
